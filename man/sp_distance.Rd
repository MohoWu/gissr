% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/sp_distance.R
\name{sp_distance}
\alias{sp_distance}
\title{Function to find distances between two spatial objects in metres or
kilometres.}
\usage{
sp_distance(sp.1, sp.2, cores = 1, unit = "m")
}
\arguments{
\item{sp.1}{Spatial object one.}

\item{sp.2}{Spatial object two.}

\item{cores}{Number of cores for the function to use. Not available for
Windows systems.}

\item{unit}{If \code{"km"}, the returned vector is returned in kilometres
rather than metres.}
}
\description{
\code{sp_distance} calculates the distance between a spatial object and
another spatial object. An example of usage is when an object containing
locations of cities is tested against coastline information to determine how
far cities are away from the coast.
}
\details{
\code{sp_distance} uses \code{rgeos::gDistance} for the distance calculations.
This function returns distances based on the unit of the projection system
contained within the spatial objects. When spatial objects are used with
\code{sp_distance} which have projection systems without metre units (such as
WGS84), the Mollweide projection system is used by default. The Mollweide
projection is applicable in any location on Earth, but the accuracy of the
returned values is dependent on location.

If the spatial objects are located in a zone which has a more appropriate
projection system, it is highly recommended that this is used. For example,
spatial data in New Zealand should be projected in the New Zealand Transverse
Mercator 2000 while data in the UK should be projected in British National
Grid; both of which have metre units (\code{+units=m}).

\code{sp_distance} supports parallel processing by forking the
\code{rgeos::gDistance} function across multiple cores. This can make the
distance calculations faster.
}
\examples{
\dontrun{
# Simple usage
# Calculate the distances of places from the coastline
distances <- sp_distance(sp.places, sp.coast.line, unit = "km")

# Speed the function up by using multiple system cores
distances <- sp_distance(sp.places, sp.coast.line, unit = "km", cores = 4)


# Usage for transforming a data frame
# Load shapefiles
# Coastline, spatial lines
sp.coast.line <- sp_transform("coastlines/coastlines")

# Places in the UK, spatial points
sp.places <- sp_transform("great-britain/places")

# Get a data frame from the sp.places object
data.places <- data.frame(sp.places)

# Find distances between every place in sp.places and sp.coast.line
# We are in the UK, therefore the British National Grid has been used as the
# projection system

# Apply parallel function and add variable to data frame
data.places$distance <- sp_distance(sp.places, sp.coast.line, unit = "km",
                                    cores = 4)

# Have a look
head(data.places)

London 33.4
Basingstoke 43.5
York 37
Tobermory 0.22
Charlbury 60.3

# London will be dependent on where the coastline is set after the River
# Thames's mouth.
}
}
\author{
Stuart K. Grange
}
\seealso{
\code{\link{gDistance}}, \code{\link{sp_transform}},
\code{\link{mclapply}}
}

